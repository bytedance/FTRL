{"calculate": "from typing import Any, Dict, List\n\n\ndef calculate(data: Dict[str, Any], expression: str) -> str:\n    import json\n    from copy import deepcopy\n    if not all(char in \"0123456789+-*/(). \" for char in expression):\n        return \"Error: invalid characters in expression\"\n    try:\n        # Evaluate the mathematical expression safely\n        return str(round(float(eval(expression, {\"__builtins__\": None}, {})), 2))\n    except Exception as e:\n        return f\"Error: {e}\"", "cancel_pending_order": "from typing import Any, Dict, List\n\n\ndef cancel_pending_order(data: Dict[str, Any], order_id: str, reason: str) -> str:\n    import json\n    from copy import deepcopy\n    # check order exists and is pending\n    orders = data[\"orders\"]\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"pending\":\n        return \"Error: non-pending order cannot be cancelled\"\n\n    # check reason\n    if reason not in [\"no longer needed\", \"ordered by mistake\"]:\n        return \"Error: invalid reason\"\n\n    # handle refund\n    refunds = []\n    for payment in order[\"payment_history\"]:\n        payment_id = payment[\"payment_method_id\"]\n        refund = {\n            \"transaction_type\": \"refund\",\n            \"amount\": payment[\"amount\"],\n            \"payment_method_id\": payment_id,\n        }\n        refunds.append(refund)\n        if \"gift_card\" in payment_id:  # refund to gift card immediately\n            payment_method = data[\"users\"][order[\"user_id\"]][\"payment_methods\"][\n                payment_id\n            ]\n            payment_method[\"balance\"] += payment[\"amount\"]\n            payment_method[\"balance\"] = round(payment_method[\"balance\"], 2)\n\n    # update order status\n    order[\"status\"] = \"cancelled\"\n    order[\"cancel_reason\"] = reason\n    order[\"payment_history\"].extend(refunds)\n\n    return json.dumps(order)", "exchange_delivered_order_items": "from typing import Any, Dict, List\n\n\ndef exchange_delivered_order_items(\n    data: Dict[str, Any],\n    order_id: str,\n    item_ids: List[str],\n    new_item_ids: List[str],\n    payment_method_id: str,\n) -> str:\n    import json\n    from copy import deepcopy\n    products, orders, users = data[\"products\"], data[\"orders\"], data[\"users\"]\n\n    # check order exists and is delivered\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"delivered\":\n        return \"Error: non-delivered order cannot be exchanged\"\n\n    # check the items to be exchanged exist\n    all_item_ids = [item[\"item_id\"] for item in order[\"items\"]]\n    for item_id in item_ids:\n        if item_ids.count(item_id) > all_item_ids.count(item_id):\n            return f\"Error: {item_id} not found\"\n\n    # check new items exist and match old items and are available\n    if len(item_ids) != len(new_item_ids):\n        return \"Error: the number of items to be exchanged should match\"\n\n    diff_price = 0\n    for item_id, new_item_id in zip(item_ids, new_item_ids):\n        item = [item for item in order[\"items\"] if item[\"item_id\"] == item_id][0]\n        product_id = item[\"product_id\"]\n        if not (\n            new_item_id in products[product_id][\"variants\"]\n            and products[product_id][\"variants\"][new_item_id][\"available\"]\n        ):\n            return f\"Error: new item {new_item_id} not found or available\"\n\n        old_price = item[\"price\"]\n        new_price = products[product_id][\"variants\"][new_item_id][\"price\"]\n        diff_price += new_price - old_price\n\n    diff_price = round(diff_price, 2)\n\n    # check payment method exists and can cover the price difference if gift card\n    if payment_method_id not in users[order[\"user_id\"]][\"payment_methods\"]:\n        return \"Error: payment method not found\"\n\n    payment_method = users[order[\"user_id\"]][\"payment_methods\"][payment_method_id]\n    if (\n        payment_method[\"source\"] == \"gift_card\"\n        and payment_method[\"balance\"] < diff_price\n    ):\n        return (\n            \"Error: insufficient gift card balance to pay for the price difference\"\n        )\n\n    # modify the order\n    order[\"status\"] = \"exchange requested\"\n    order[\"exchange_items\"] = sorted(item_ids)\n    order[\"exchange_new_items\"] = sorted(new_item_ids)\n    order[\"exchange_payment_method_id\"] = payment_method_id\n    order[\"exchange_price_difference\"] = diff_price\n\n    return json.dumps(order)", "find_user_id_by_email": "from typing import Any, Dict, List\n\n\ndef find_user_id_by_email(data: Dict[str, Any], email: str) -> str:\n    import json\n    from copy import deepcopy\n    users = data[\"users\"]\n    for user_id, profile in users.items():\n        if profile[\"email\"].lower() == email.lower():\n            return user_id\n    return \"Error: user not found\"", "find_user_id_by_name_zip": "from typing import Any, Dict, List\n\n\ndef find_user_id_by_name_zip(data: Dict[str, Any], first_name: str, last_name: str, zip: str) -> str:\n    import json\n    from copy import deepcopy\n    users = data[\"users\"]\n    for user_id, profile in users.items():\n        if (\n            profile[\"name\"][\"first_name\"].lower() == first_name.lower()\n            and profile[\"name\"][\"last_name\"].lower() == last_name.lower()\n            and profile[\"address\"][\"zip\"] == zip\n        ):\n            return user_id\n    return \"Error: user not found\"", "get_order_details": "from typing import Any, Dict, List\n\n\ndef get_order_details(data: Dict[str, Any], order_id: str) -> str:\n    import json\n    from copy import deepcopy\n    orders = data[\"orders\"]\n    if order_id in orders:\n        return json.dumps(orders[order_id])\n    return \"Error: order not found\"", "get_product_details": "from typing import Any, Dict, List\n\n\ndef get_product_details(data: Dict[str, Any], product_id: str) -> str:\n    import json\n    from copy import deepcopy\n    products = data[\"products\"]\n    if product_id in products:\n        return json.dumps(products[product_id])\n    return \"Error: product not found\"", "get_user_details": "from typing import Any, Dict, List\n\n\ndef get_user_details(data: Dict[str, Any], user_id: str) -> str:\n    import json\n    from copy import deepcopy\n    users = data[\"users\"]\n    if user_id in users:\n        return json.dumps(users[user_id])\n    return \"Error: user not found\"", "list_all_product_types": "from typing import Any, Dict, List\n\n\ndef list_all_product_types(data: Dict[str, Any]) -> str:\n    import json\n    from copy import deepcopy\n    products = data[\"products\"]\n    product_dict = {\n        product[\"name\"]: product[\"product_id\"] for product in products.values()\n    }\n    product_dict = dict(sorted(product_dict.items()))\n    return json.dumps(product_dict)", "modify_pending_order_address": "from typing import Any, Dict, List\n\n\ndef modify_pending_order_address(\n    data: Dict[str, Any],\n    order_id: str,\n    address1: str,\n    address2: str,\n    city: str,\n    state: str,\n    country: str,\n    zip: str,\n) -> str:\n    import json\n    from copy import deepcopy\n    # Check if the order exists and is pending\n    orders = data[\"orders\"]\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"pending\":\n        return \"Error: non-pending order cannot be modified\"\n\n    # Modify the address\n    order[\"address\"] = {\n        \"address1\": address1,\n        \"address2\": address2,\n        \"city\": city,\n        \"state\": state,\n        \"country\": country,\n        \"zip\": zip,\n    }\n    return json.dumps(order)", "modify_pending_order_items": "from typing import Any, Dict, List\n\n\ndef modify_pending_order_items(\n    data: Dict[str, Any],\n    order_id: str,\n    item_ids: List[str],\n    new_item_ids: List[str],\n    payment_method_id: str,\n) -> str:\n    import json\n    from copy import deepcopy\n    products, orders, users = data[\"products\"], data[\"orders\"], data[\"users\"]\n\n    # Check if the order exists and is pending\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"pending\":\n        return \"Error: non-pending order cannot be modified\"\n\n    # Check if the items to be modified exist\n    all_item_ids = [item[\"item_id\"] for item in order[\"items\"]]\n    for item_id in item_ids:\n        if item_ids.count(item_id) > all_item_ids.count(item_id):\n            return f\"Error: {item_id} not found\"\n\n    # Check new items exist, match old items, and are available\n    if len(item_ids) != len(new_item_ids):\n        return \"Error: the number of items to be exchanged should match\"\n\n    diff_price = 0\n    for item_id, new_item_id in zip(item_ids, new_item_ids):\n        item = [item for item in order[\"items\"] if item[\"item_id\"] == item_id][0]\n        product_id = item[\"product_id\"]\n        if not (\n            new_item_id in products[product_id][\"variants\"]\n            and products[product_id][\"variants\"][new_item_id][\"available\"]\n        ):\n            return f\"Error: new item {new_item_id} not found or available\"\n\n        old_price = item[\"price\"]\n        new_price = products[product_id][\"variants\"][new_item_id][\"price\"]\n        diff_price += new_price - old_price\n\n    # Check if the payment method exists\n    if payment_method_id not in users[order[\"user_id\"]][\"payment_methods\"]:\n        return \"Error: payment method not found\"\n\n    # If the new item is more expensive, check if the gift card has enough balance\n    payment_method = users[order[\"user_id\"]][\"payment_methods\"][payment_method_id]\n    if (\n        payment_method[\"source\"] == \"gift_card\"\n        and payment_method[\"balance\"] < diff_price\n    ):\n        return \"Error: insufficient gift card balance to pay for the new item\"\n\n    # Handle the payment or refund\n    order[\"payment_history\"].append(\n        {\n            \"transaction_type\": \"payment\" if diff_price > 0 else \"refund\",\n            \"amount\": abs(diff_price),\n            \"payment_method_id\": payment_method_id,\n        }\n    )\n    if payment_method[\"source\"] == \"gift_card\":\n        payment_method[\"balance\"] -= diff_price\n        payment_method[\"balance\"] = round(payment_method[\"balance\"], 2)\n\n    # Modify the order\n    for item_id, new_item_id in zip(item_ids, new_item_ids):\n        item = [item for item in order[\"items\"] if item[\"item_id\"] == item_id][0]\n        item[\"item_id\"] = new_item_id\n        item[\"price\"] = products[item[\"product_id\"]][\"variants\"][new_item_id][\n            \"price\"\n        ]\n        item[\"options\"] = products[item[\"product_id\"]][\"variants\"][new_item_id][\n            \"options\"\n        ]\n    order[\"status\"] = \"pending (item modified)\"\n\n    return json.dumps(order)", "modify_pending_order_payment": "from typing import Any, Dict, List\n\n\ndef modify_pending_order_payment(\n    data: Dict[str, Any],\n    order_id: str,\n    payment_method_id: str,\n) -> str:\n    import json\n    from copy import deepcopy\n    orders = data[\"orders\"]\n\n    # Check if the order exists and is pending\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"pending\":\n        return \"Error: non-pending order cannot be modified\"\n\n    # Check if the payment method exists\n    if payment_method_id not in data[\"users\"][order[\"user_id\"]][\"payment_methods\"]:\n        return \"Error: payment method not found\"\n\n    # Check that the payment history should only have one payment\n    if (\n        len(order[\"payment_history\"]) > 1\n        or order[\"payment_history\"][0][\"transaction_type\"] != \"payment\"\n    ):\n        return \"Error: there should be exactly one payment for a pending order\"\n\n    # Check that the payment method is different\n    if order[\"payment_history\"][0][\"payment_method_id\"] == payment_method_id:\n        return (\n            \"Error: the new payment method should be different from the current one\"\n        )\n\n    amount = order[\"payment_history\"][0][\"amount\"]\n    payment_method = data[\"users\"][order[\"user_id\"]][\"payment_methods\"][\n        payment_method_id\n    ]\n\n    # Check if the new payment method has enough balance if it is a gift card\n    if (\n        payment_method[\"source\"] == \"gift_card\"\n        and payment_method[\"balance\"] < amount\n    ):\n        return \"Error: insufficient gift card balance to pay for the order\"\n\n    # Modify the payment method\n    order[\"payment_history\"].extend(\n        [\n            {\n                \"transaction_type\": \"payment\",\n                \"amount\": amount,\n                \"payment_method_id\": payment_method_id,\n            },\n            {\n                \"transaction_type\": \"refund\",\n                \"amount\": amount,\n                \"payment_method_id\": order[\"payment_history\"][0][\n                    \"payment_method_id\"\n                ],\n            },\n        ]\n    )\n\n    # If payment is made by gift card, update the balance\n    if payment_method[\"source\"] == \"gift_card\":\n        payment_method[\"balance\"] -= amount\n        payment_method[\"balance\"] = round(payment_method[\"balance\"], 2)\n\n    # If refund is made to a gift card, update the balance\n    if \"gift_card\" in order[\"payment_history\"][0][\"payment_method_id\"]:\n        old_payment_method = data[\"users\"][order[\"user_id\"]][\"payment_methods\"][\n            order[\"payment_history\"][0][\"payment_method_id\"]\n        ]\n        old_payment_method[\"balance\"] += amount\n        old_payment_method[\"balance\"] = round(old_payment_method[\"balance\"], 2)\n\n    return json.dumps(order)", "modify_user_address": "from typing import Any, Dict, List\n\n\ndef modify_user_address(\n    data: Dict[str, Any],\n    user_id: str,\n    address1: str,\n    address2: str,\n    city: str,\n    state: str,\n    country: str,\n    zip: str,\n) -> str:\n    import json\n    from copy import deepcopy\n    users = data[\"users\"]\n    if user_id not in users:\n        return \"Error: user not found\"\n    user = users[user_id]\n    user[\"address\"] = {\n        \"address1\": address1,\n        \"address2\": address2,\n        \"city\": city,\n        \"state\": state,\n        \"country\": country,\n        \"zip\": zip,\n    }\n    return json.dumps(user)", "return_delivered_order_items": "from typing import Any, Dict, List\n\n\ndef return_delivered_order_items(\n    data: Dict[str, Any], order_id: str, item_ids: List[str], payment_method_id: str\n) -> str:\n    import json\n    from copy import deepcopy\n    orders = data[\"orders\"]\n\n    # Check if the order exists and is delivered\n    if order_id not in orders:\n        return \"Error: order not found\"\n    order = orders[order_id]\n    if order[\"status\"] != \"delivered\":\n        return \"Error: non-delivered order cannot be returned\"\n\n    # Check if the payment method exists and is either the original payment method or a gift card\n    if payment_method_id not in data[\"users\"][order[\"user_id\"]][\"payment_methods\"]:\n        return \"Error: payment method not found\"\n    if (\n        \"gift_card\" not in payment_method_id\n        and payment_method_id != order[\"payment_history\"][0][\"payment_method_id\"]\n    ):\n        return \"Error: payment method should be either the original payment method or a gift card\"\n\n    # Check if the items to be returned exist (there could be duplicate items in either list)\n    all_item_ids = [item[\"item_id\"] for item in order[\"items\"]]\n    for item_id in item_ids:\n        if item_ids.count(item_id) > all_item_ids.count(item_id):\n            return \"Error: some item not found\"\n\n    # Update the order status\n    order[\"status\"] = \"return requested\"\n    order[\"return_items\"] = sorted(item_ids)\n    order[\"return_payment_method_id\"] = payment_method_id\n\n    return json.dumps(order)", "think": "from typing import Any, Dict, List\n\n\ndef think(data: Dict[str, Any], thought: str) -> str:\n    import json\n    from copy import deepcopy\n    # This method does not change the state of the data; it simply returns an empty string.\n    return \"\"", "transfer_to_human_agents": "from typing import Any, Dict, List\n\n\ndef transfer_to_human_agents(data: Dict[str, Any], summary: str) -> str:\n    import json\n    from copy import deepcopy\n    # This method simulates the transfer to a human agent.\n    return \"Transfer successful\""}